// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/ntiGideon/cvCraft/ent/certification"
	"github.com/ntiGideon/cvCraft/ent/education"
	"github.com/ntiGideon/cvCraft/ent/experience"
	"github.com/ntiGideon/cvCraft/ent/personalinfo"
	"github.com/ntiGideon/cvCraft/ent/predicate"
	"github.com/ntiGideon/cvCraft/ent/project"
	"github.com/ntiGideon/cvCraft/ent/resume"
	"github.com/ntiGideon/cvCraft/ent/session"
	"github.com/ntiGideon/cvCraft/ent/skill"
	"github.com/ntiGideon/cvCraft/ent/template"
	"github.com/ntiGideon/cvCraft/ent/user"
	"github.com/ntiGideon/cvCraft/internal/models"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCertification = "Certification"
	TypeEducation     = "Education"
	TypeExperience    = "Experience"
	TypePersonalInfo  = "PersonalInfo"
	TypeProject       = "Project"
	TypeResume        = "Resume"
	TypeSession       = "Session"
	TypeSkill         = "Skill"
	TypeTemplate      = "Template"
	TypeUser          = "User"
)

// CertificationMutation represents an operation that mutates the Certification nodes in the graph.
type CertificationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	organization    *string
	issue_date      *time.Time
	expiration_date *time.Time
	credential_id   *string
	url             *string
	clearedFields   map[string]struct{}
	resume          map[int]struct{}
	removedresume   map[int]struct{}
	clearedresume   bool
	done            bool
	oldValue        func(context.Context) (*Certification, error)
	predicates      []predicate.Certification
}

var _ ent.Mutation = (*CertificationMutation)(nil)

// certificationOption allows management of the mutation configuration using functional options.
type certificationOption func(*CertificationMutation)

// newCertificationMutation creates new mutation for the Certification entity.
func newCertificationMutation(c config, op Op, opts ...certificationOption) *CertificationMutation {
	m := &CertificationMutation{
		config:        c,
		op:            op,
		typ:           TypeCertification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificationID sets the ID field of the mutation.
func withCertificationID(id int) certificationOption {
	return func(m *CertificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Certification
		)
		m.oldValue = func(ctx context.Context) (*Certification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertification sets the old Certification of the mutation.
func withCertification(node *Certification) certificationOption {
	return func(m *CertificationMutation) {
		m.oldValue = func(context.Context) (*Certification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CertificationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CertificationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CertificationMutation) ResetName() {
	m.name = nil
}

// SetOrganization sets the "organization" field.
func (m *CertificationMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *CertificationMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ResetOrganization resets all changes to the "organization" field.
func (m *CertificationMutation) ResetOrganization() {
	m.organization = nil
}

// SetIssueDate sets the "issue_date" field.
func (m *CertificationMutation) SetIssueDate(t time.Time) {
	m.issue_date = &t
}

// IssueDate returns the value of the "issue_date" field in the mutation.
func (m *CertificationMutation) IssueDate() (r time.Time, exists bool) {
	v := m.issue_date
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueDate returns the old "issue_date" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldIssueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueDate: %w", err)
	}
	return oldValue.IssueDate, nil
}

// ResetIssueDate resets all changes to the "issue_date" field.
func (m *CertificationMutation) ResetIssueDate() {
	m.issue_date = nil
}

// SetExpirationDate sets the "expiration_date" field.
func (m *CertificationMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *CertificationMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldExpirationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *CertificationMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[certification.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *CertificationMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[certification.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *CertificationMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, certification.FieldExpirationDate)
}

// SetCredentialID sets the "credential_id" field.
func (m *CertificationMutation) SetCredentialID(s string) {
	m.credential_id = &s
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *CertificationMutation) CredentialID() (r string, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldCredentialID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ClearCredentialID clears the value of the "credential_id" field.
func (m *CertificationMutation) ClearCredentialID() {
	m.credential_id = nil
	m.clearedFields[certification.FieldCredentialID] = struct{}{}
}

// CredentialIDCleared returns if the "credential_id" field was cleared in this mutation.
func (m *CertificationMutation) CredentialIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldCredentialID]
	return ok
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *CertificationMutation) ResetCredentialID() {
	m.credential_id = nil
	delete(m.clearedFields, certification.FieldCredentialID)
}

// SetURL sets the "url" field.
func (m *CertificationMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CertificationMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *CertificationMutation) ClearURL() {
	m.url = nil
	m.clearedFields[certification.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *CertificationMutation) URLCleared() bool {
	_, ok := m.clearedFields[certification.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *CertificationMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, certification.FieldURL)
}

// AddResumeIDs adds the "resume" edge to the Resume entity by ids.
func (m *CertificationMutation) AddResumeIDs(ids ...int) {
	if m.resume == nil {
		m.resume = make(map[int]struct{})
	}
	for i := range ids {
		m.resume[ids[i]] = struct{}{}
	}
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *CertificationMutation) ClearResume() {
	m.clearedresume = true
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *CertificationMutation) ResumeCleared() bool {
	return m.clearedresume
}

// RemoveResumeIDs removes the "resume" edge to the Resume entity by IDs.
func (m *CertificationMutation) RemoveResumeIDs(ids ...int) {
	if m.removedresume == nil {
		m.removedresume = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resume, ids[i])
		m.removedresume[ids[i]] = struct{}{}
	}
}

// RemovedResume returns the removed IDs of the "resume" edge to the Resume entity.
func (m *CertificationMutation) RemovedResumeIDs() (ids []int) {
	for id := range m.removedresume {
		ids = append(ids, id)
	}
	return
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
func (m *CertificationMutation) ResumeIDs() (ids []int) {
	for id := range m.resume {
		ids = append(ids, id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *CertificationMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
	m.removedresume = nil
}

// Where appends a list predicates to the CertificationMutation builder.
func (m *CertificationMutation) Where(ps ...predicate.Certification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Certification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Certification).
func (m *CertificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, certification.FieldName)
	}
	if m.organization != nil {
		fields = append(fields, certification.FieldOrganization)
	}
	if m.issue_date != nil {
		fields = append(fields, certification.FieldIssueDate)
	}
	if m.expiration_date != nil {
		fields = append(fields, certification.FieldExpirationDate)
	}
	if m.credential_id != nil {
		fields = append(fields, certification.FieldCredentialID)
	}
	if m.url != nil {
		fields = append(fields, certification.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certification.FieldName:
		return m.Name()
	case certification.FieldOrganization:
		return m.Organization()
	case certification.FieldIssueDate:
		return m.IssueDate()
	case certification.FieldExpirationDate:
		return m.ExpirationDate()
	case certification.FieldCredentialID:
		return m.CredentialID()
	case certification.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certification.FieldName:
		return m.OldName(ctx)
	case certification.FieldOrganization:
		return m.OldOrganization(ctx)
	case certification.FieldIssueDate:
		return m.OldIssueDate(ctx)
	case certification.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	case certification.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case certification.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Certification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certification.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case certification.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case certification.FieldIssueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueDate(v)
		return nil
	case certification.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	case certification.FieldCredentialID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case certification.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certification.FieldExpirationDate) {
		fields = append(fields, certification.FieldExpirationDate)
	}
	if m.FieldCleared(certification.FieldCredentialID) {
		fields = append(fields, certification.FieldCredentialID)
	}
	if m.FieldCleared(certification.FieldURL) {
		fields = append(fields, certification.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificationMutation) ClearField(name string) error {
	switch name {
	case certification.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	case certification.FieldCredentialID:
		m.ClearCredentialID()
		return nil
	case certification.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Certification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificationMutation) ResetField(name string) error {
	switch name {
	case certification.FieldName:
		m.ResetName()
		return nil
	case certification.FieldOrganization:
		m.ResetOrganization()
		return nil
	case certification.FieldIssueDate:
		m.ResetIssueDate()
		return nil
	case certification.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	case certification.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case certification.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, certification.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certification.EdgeResume:
		ids := make([]ent.Value, 0, len(m.resume))
		for id := range m.resume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedresume != nil {
		edges = append(edges, certification.EdgeResume)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case certification.EdgeResume:
		ids := make([]ent.Value, 0, len(m.removedresume))
		for id := range m.removedresume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, certification.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificationMutation) EdgeCleared(name string) bool {
	switch name {
	case certification.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Certification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificationMutation) ResetEdge(name string) error {
	switch name {
	case certification.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown Certification edge %s", name)
}

// EducationMutation represents an operation that mutates the Education nodes in the graph.
type EducationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	institution   *string
	degree        *string
	field         *string
	start_date    *time.Time
	end_date      *time.Time
	description   *string
	grade         *string
	clearedFields map[string]struct{}
	resume        map[int]struct{}
	removedresume map[int]struct{}
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*Education, error)
	predicates    []predicate.Education
}

var _ ent.Mutation = (*EducationMutation)(nil)

// educationOption allows management of the mutation configuration using functional options.
type educationOption func(*EducationMutation)

// newEducationMutation creates new mutation for the Education entity.
func newEducationMutation(c config, op Op, opts ...educationOption) *EducationMutation {
	m := &EducationMutation{
		config:        c,
		op:            op,
		typ:           TypeEducation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationID sets the ID field of the mutation.
func withEducationID(id int) educationOption {
	return func(m *EducationMutation) {
		var (
			err   error
			once  sync.Once
			value *Education
		)
		m.oldValue = func(ctx context.Context) (*Education, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Education.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducation sets the old Education of the mutation.
func withEducation(node *Education) educationOption {
	return func(m *EducationMutation) {
		m.oldValue = func(context.Context) (*Education, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Education.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInstitution sets the "institution" field.
func (m *EducationMutation) SetInstitution(s string) {
	m.institution = &s
}

// Institution returns the value of the "institution" field in the mutation.
func (m *EducationMutation) Institution() (r string, exists bool) {
	v := m.institution
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitution returns the old "institution" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitution: %w", err)
	}
	return oldValue.Institution, nil
}

// ResetInstitution resets all changes to the "institution" field.
func (m *EducationMutation) ResetInstitution() {
	m.institution = nil
}

// SetDegree sets the "degree" field.
func (m *EducationMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the value of the "degree" field in the mutation.
func (m *EducationMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old "degree" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ResetDegree resets all changes to the "degree" field.
func (m *EducationMutation) ResetDegree() {
	m.degree = nil
}

// SetFieldField sets the "field" field.
func (m *EducationMutation) SetFieldField(s string) {
	m.field = &s
}

// GetField returns the value of the "field" field in the mutation.
func (m *EducationMutation) GetField() (r string, exists bool) {
	v := m.field
	if v == nil {
		return
	}
	return *v, true
}

// GetOldField returns the old "field" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) GetOldField(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("GetOldField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("GetOldField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for GetOldField: %w", err)
	}
	return oldValue.Field, nil
}

// ResetFieldField resets all changes to the "field" field.
func (m *EducationMutation) ResetFieldField() {
	m.field = nil
}

// SetStartDate sets the "start_date" field.
func (m *EducationMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *EducationMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *EducationMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *EducationMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *EducationMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *EducationMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[education.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *EducationMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[education.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *EducationMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, education.FieldEndDate)
}

// SetDescription sets the "description" field.
func (m *EducationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EducationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EducationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[education.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EducationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[education.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EducationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, education.FieldDescription)
}

// SetGrade sets the "grade" field.
func (m *EducationMutation) SetGrade(s string) {
	m.grade = &s
}

// Grade returns the value of the "grade" field in the mutation.
func (m *EducationMutation) Grade() (r string, exists bool) {
	v := m.grade
	if v == nil {
		return
	}
	return *v, true
}

// OldGrade returns the old "grade" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldGrade(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrade: %w", err)
	}
	return oldValue.Grade, nil
}

// ClearGrade clears the value of the "grade" field.
func (m *EducationMutation) ClearGrade() {
	m.grade = nil
	m.clearedFields[education.FieldGrade] = struct{}{}
}

// GradeCleared returns if the "grade" field was cleared in this mutation.
func (m *EducationMutation) GradeCleared() bool {
	_, ok := m.clearedFields[education.FieldGrade]
	return ok
}

// ResetGrade resets all changes to the "grade" field.
func (m *EducationMutation) ResetGrade() {
	m.grade = nil
	delete(m.clearedFields, education.FieldGrade)
}

// AddResumeIDs adds the "resume" edge to the Resume entity by ids.
func (m *EducationMutation) AddResumeIDs(ids ...int) {
	if m.resume == nil {
		m.resume = make(map[int]struct{})
	}
	for i := range ids {
		m.resume[ids[i]] = struct{}{}
	}
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *EducationMutation) ClearResume() {
	m.clearedresume = true
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *EducationMutation) ResumeCleared() bool {
	return m.clearedresume
}

// RemoveResumeIDs removes the "resume" edge to the Resume entity by IDs.
func (m *EducationMutation) RemoveResumeIDs(ids ...int) {
	if m.removedresume == nil {
		m.removedresume = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resume, ids[i])
		m.removedresume[ids[i]] = struct{}{}
	}
}

// RemovedResume returns the removed IDs of the "resume" edge to the Resume entity.
func (m *EducationMutation) RemovedResumeIDs() (ids []int) {
	for id := range m.removedresume {
		ids = append(ids, id)
	}
	return
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
func (m *EducationMutation) ResumeIDs() (ids []int) {
	for id := range m.resume {
		ids = append(ids, id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *EducationMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
	m.removedresume = nil
}

// Where appends a list predicates to the EducationMutation builder.
func (m *EducationMutation) Where(ps ...predicate.Education) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Education, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Education).
func (m *EducationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.institution != nil {
		fields = append(fields, education.FieldInstitution)
	}
	if m.degree != nil {
		fields = append(fields, education.FieldDegree)
	}
	if m.field != nil {
		fields = append(fields, education.FieldField)
	}
	if m.start_date != nil {
		fields = append(fields, education.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, education.FieldEndDate)
	}
	if m.description != nil {
		fields = append(fields, education.FieldDescription)
	}
	if m.grade != nil {
		fields = append(fields, education.FieldGrade)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case education.FieldInstitution:
		return m.Institution()
	case education.FieldDegree:
		return m.Degree()
	case education.FieldField:
		return m.GetField()
	case education.FieldStartDate:
		return m.StartDate()
	case education.FieldEndDate:
		return m.EndDate()
	case education.FieldDescription:
		return m.Description()
	case education.FieldGrade:
		return m.Grade()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case education.FieldInstitution:
		return m.OldInstitution(ctx)
	case education.FieldDegree:
		return m.OldDegree(ctx)
	case education.FieldField:
		return m.GetOldField(ctx)
	case education.FieldStartDate:
		return m.OldStartDate(ctx)
	case education.FieldEndDate:
		return m.OldEndDate(ctx)
	case education.FieldDescription:
		return m.OldDescription(ctx)
	case education.FieldGrade:
		return m.OldGrade(ctx)
	}
	return nil, fmt.Errorf("unknown Education field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case education.FieldInstitution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitution(v)
		return nil
	case education.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	case education.FieldField:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldField(v)
		return nil
	case education.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case education.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case education.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case education.FieldGrade:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrade(v)
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Education numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(education.FieldEndDate) {
		fields = append(fields, education.FieldEndDate)
	}
	if m.FieldCleared(education.FieldDescription) {
		fields = append(fields, education.FieldDescription)
	}
	if m.FieldCleared(education.FieldGrade) {
		fields = append(fields, education.FieldGrade)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationMutation) ClearField(name string) error {
	switch name {
	case education.FieldEndDate:
		m.ClearEndDate()
		return nil
	case education.FieldDescription:
		m.ClearDescription()
		return nil
	case education.FieldGrade:
		m.ClearGrade()
		return nil
	}
	return fmt.Errorf("unknown Education nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationMutation) ResetField(name string) error {
	switch name {
	case education.FieldInstitution:
		m.ResetInstitution()
		return nil
	case education.FieldDegree:
		m.ResetDegree()
		return nil
	case education.FieldField:
		m.ResetFieldField()
		return nil
	case education.FieldStartDate:
		m.ResetStartDate()
		return nil
	case education.FieldEndDate:
		m.ResetEndDate()
		return nil
	case education.FieldDescription:
		m.ResetDescription()
		return nil
	case education.FieldGrade:
		m.ResetGrade()
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, education.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case education.EdgeResume:
		ids := make([]ent.Value, 0, len(m.resume))
		for id := range m.resume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedresume != nil {
		edges = append(edges, education.EdgeResume)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case education.EdgeResume:
		ids := make([]ent.Value, 0, len(m.removedresume))
		for id := range m.removedresume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, education.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationMutation) EdgeCleared(name string) bool {
	switch name {
	case education.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Education unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationMutation) ResetEdge(name string) error {
	switch name {
	case education.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown Education edge %s", name)
}

// ExperienceMutation represents an operation that mutates the Experience nodes in the graph.
type ExperienceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	company       *string
	location      *string
	start_date    *time.Time
	end_date      *time.Time
	description   *string
	skills        *string
	current       *bool
	clearedFields map[string]struct{}
	resume        map[int]struct{}
	removedresume map[int]struct{}
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*Experience, error)
	predicates    []predicate.Experience
}

var _ ent.Mutation = (*ExperienceMutation)(nil)

// experienceOption allows management of the mutation configuration using functional options.
type experienceOption func(*ExperienceMutation)

// newExperienceMutation creates new mutation for the Experience entity.
func newExperienceMutation(c config, op Op, opts ...experienceOption) *ExperienceMutation {
	m := &ExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExperienceID sets the ID field of the mutation.
func withExperienceID(id int) experienceOption {
	return func(m *ExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *Experience
		)
		m.oldValue = func(ctx context.Context) (*Experience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Experience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExperience sets the old Experience of the mutation.
func withExperience(node *Experience) experienceOption {
	return func(m *ExperienceMutation) {
		m.oldValue = func(context.Context) (*Experience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExperienceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExperienceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Experience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ExperienceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ExperienceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ExperienceMutation) ResetTitle() {
	m.title = nil
}

// SetCompany sets the "company" field.
func (m *ExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *ExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *ExperienceMutation) ResetCompany() {
	m.company = nil
}

// SetLocation sets the "location" field.
func (m *ExperienceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ExperienceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ExperienceMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[experience.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ExperienceMutation) LocationCleared() bool {
	_, ok := m.clearedFields[experience.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ExperienceMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, experience.FieldLocation)
}

// SetStartDate sets the "start_date" field.
func (m *ExperienceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ExperienceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ExperienceMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ExperienceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ExperienceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ExperienceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[experience.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ExperienceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[experience.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ExperienceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, experience.FieldEndDate)
}

// SetDescription sets the "description" field.
func (m *ExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ExperienceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[experience.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ExperienceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[experience.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ExperienceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, experience.FieldDescription)
}

// SetSkills sets the "skills" field.
func (m *ExperienceMutation) SetSkills(s string) {
	m.skills = &s
}

// Skills returns the value of the "skills" field in the mutation.
func (m *ExperienceMutation) Skills() (r string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldSkills(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// ClearSkills clears the value of the "skills" field.
func (m *ExperienceMutation) ClearSkills() {
	m.skills = nil
	m.clearedFields[experience.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *ExperienceMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[experience.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *ExperienceMutation) ResetSkills() {
	m.skills = nil
	delete(m.clearedFields, experience.FieldSkills)
}

// SetCurrent sets the "current" field.
func (m *ExperienceMutation) SetCurrent(b bool) {
	m.current = &b
}

// Current returns the value of the "current" field in the mutation.
func (m *ExperienceMutation) Current() (r bool, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// ResetCurrent resets all changes to the "current" field.
func (m *ExperienceMutation) ResetCurrent() {
	m.current = nil
}

// AddResumeIDs adds the "resume" edge to the Resume entity by ids.
func (m *ExperienceMutation) AddResumeIDs(ids ...int) {
	if m.resume == nil {
		m.resume = make(map[int]struct{})
	}
	for i := range ids {
		m.resume[ids[i]] = struct{}{}
	}
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ExperienceMutation) ClearResume() {
	m.clearedresume = true
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ExperienceMutation) ResumeCleared() bool {
	return m.clearedresume
}

// RemoveResumeIDs removes the "resume" edge to the Resume entity by IDs.
func (m *ExperienceMutation) RemoveResumeIDs(ids ...int) {
	if m.removedresume == nil {
		m.removedresume = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resume, ids[i])
		m.removedresume[ids[i]] = struct{}{}
	}
}

// RemovedResume returns the removed IDs of the "resume" edge to the Resume entity.
func (m *ExperienceMutation) RemovedResumeIDs() (ids []int) {
	for id := range m.removedresume {
		ids = append(ids, id)
	}
	return
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
func (m *ExperienceMutation) ResumeIDs() (ids []int) {
	for id := range m.resume {
		ids = append(ids, id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ExperienceMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
	m.removedresume = nil
}

// Where appends a list predicates to the ExperienceMutation builder.
func (m *ExperienceMutation) Where(ps ...predicate.Experience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Experience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Experience).
func (m *ExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExperienceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, experience.FieldTitle)
	}
	if m.company != nil {
		fields = append(fields, experience.FieldCompany)
	}
	if m.location != nil {
		fields = append(fields, experience.FieldLocation)
	}
	if m.start_date != nil {
		fields = append(fields, experience.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, experience.FieldEndDate)
	}
	if m.description != nil {
		fields = append(fields, experience.FieldDescription)
	}
	if m.skills != nil {
		fields = append(fields, experience.FieldSkills)
	}
	if m.current != nil {
		fields = append(fields, experience.FieldCurrent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case experience.FieldTitle:
		return m.Title()
	case experience.FieldCompany:
		return m.Company()
	case experience.FieldLocation:
		return m.Location()
	case experience.FieldStartDate:
		return m.StartDate()
	case experience.FieldEndDate:
		return m.EndDate()
	case experience.FieldDescription:
		return m.Description()
	case experience.FieldSkills:
		return m.Skills()
	case experience.FieldCurrent:
		return m.Current()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case experience.FieldTitle:
		return m.OldTitle(ctx)
	case experience.FieldCompany:
		return m.OldCompany(ctx)
	case experience.FieldLocation:
		return m.OldLocation(ctx)
	case experience.FieldStartDate:
		return m.OldStartDate(ctx)
	case experience.FieldEndDate:
		return m.OldEndDate(ctx)
	case experience.FieldDescription:
		return m.OldDescription(ctx)
	case experience.FieldSkills:
		return m.OldSkills(ctx)
	case experience.FieldCurrent:
		return m.OldCurrent(ctx)
	}
	return nil, fmt.Errorf("unknown Experience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case experience.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case experience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case experience.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case experience.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case experience.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case experience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case experience.FieldSkills:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case experience.FieldCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	}
	return fmt.Errorf("unknown Experience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExperienceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExperienceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Experience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(experience.FieldLocation) {
		fields = append(fields, experience.FieldLocation)
	}
	if m.FieldCleared(experience.FieldEndDate) {
		fields = append(fields, experience.FieldEndDate)
	}
	if m.FieldCleared(experience.FieldDescription) {
		fields = append(fields, experience.FieldDescription)
	}
	if m.FieldCleared(experience.FieldSkills) {
		fields = append(fields, experience.FieldSkills)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExperienceMutation) ClearField(name string) error {
	switch name {
	case experience.FieldLocation:
		m.ClearLocation()
		return nil
	case experience.FieldEndDate:
		m.ClearEndDate()
		return nil
	case experience.FieldDescription:
		m.ClearDescription()
		return nil
	case experience.FieldSkills:
		m.ClearSkills()
		return nil
	}
	return fmt.Errorf("unknown Experience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExperienceMutation) ResetField(name string) error {
	switch name {
	case experience.FieldTitle:
		m.ResetTitle()
		return nil
	case experience.FieldCompany:
		m.ResetCompany()
		return nil
	case experience.FieldLocation:
		m.ResetLocation()
		return nil
	case experience.FieldStartDate:
		m.ResetStartDate()
		return nil
	case experience.FieldEndDate:
		m.ResetEndDate()
		return nil
	case experience.FieldDescription:
		m.ResetDescription()
		return nil
	case experience.FieldSkills:
		m.ResetSkills()
		return nil
	case experience.FieldCurrent:
		m.ResetCurrent()
		return nil
	}
	return fmt.Errorf("unknown Experience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, experience.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case experience.EdgeResume:
		ids := make([]ent.Value, 0, len(m.resume))
		for id := range m.resume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedresume != nil {
		edges = append(edges, experience.EdgeResume)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExperienceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case experience.EdgeResume:
		ids := make([]ent.Value, 0, len(m.removedresume))
		for id := range m.removedresume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, experience.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case experience.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExperienceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Experience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExperienceMutation) ResetEdge(name string) error {
	switch name {
	case experience.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown Experience edge %s", name)
}

// PersonalInfoMutation represents an operation that mutates the PersonalInfo nodes in the graph.
type PersonalInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	first_name    *string
	last_name     *string
	profession    *string
	email         *string
	phone         *string
	address       *string
	website       *string
	linkedin      *string
	github        *string
	twitter       *string
	bio           *string
	photo_url     *string
	clearedFields map[string]struct{}
	resume        *int
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*PersonalInfo, error)
	predicates    []predicate.PersonalInfo
}

var _ ent.Mutation = (*PersonalInfoMutation)(nil)

// personalinfoOption allows management of the mutation configuration using functional options.
type personalinfoOption func(*PersonalInfoMutation)

// newPersonalInfoMutation creates new mutation for the PersonalInfo entity.
func newPersonalInfoMutation(c config, op Op, opts ...personalinfoOption) *PersonalInfoMutation {
	m := &PersonalInfoMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalInfoID sets the ID field of the mutation.
func withPersonalInfoID(id int) personalinfoOption {
	return func(m *PersonalInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalInfo
		)
		m.oldValue = func(ctx context.Context) (*PersonalInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalInfo sets the old PersonalInfo of the mutation.
func withPersonalInfo(node *PersonalInfo) personalinfoOption {
	return func(m *PersonalInfoMutation) {
		m.oldValue = func(context.Context) (*PersonalInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *PersonalInfoMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *PersonalInfoMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *PersonalInfoMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *PersonalInfoMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *PersonalInfoMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *PersonalInfoMutation) ResetLastName() {
	m.last_name = nil
}

// SetProfession sets the "profession" field.
func (m *PersonalInfoMutation) SetProfession(s string) {
	m.profession = &s
}

// Profession returns the value of the "profession" field in the mutation.
func (m *PersonalInfoMutation) Profession() (r string, exists bool) {
	v := m.profession
	if v == nil {
		return
	}
	return *v, true
}

// OldProfession returns the old "profession" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldProfession(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfession is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfession requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfession: %w", err)
	}
	return oldValue.Profession, nil
}

// ResetProfession resets all changes to the "profession" field.
func (m *PersonalInfoMutation) ResetProfession() {
	m.profession = nil
}

// SetEmail sets the "email" field.
func (m *PersonalInfoMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PersonalInfoMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PersonalInfoMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *PersonalInfoMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PersonalInfoMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *PersonalInfoMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[personalinfo.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *PersonalInfoMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *PersonalInfoMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, personalinfo.FieldPhone)
}

// SetAddress sets the "address" field.
func (m *PersonalInfoMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PersonalInfoMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PersonalInfoMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[personalinfo.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PersonalInfoMutation) AddressCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PersonalInfoMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, personalinfo.FieldAddress)
}

// SetWebsite sets the "website" field.
func (m *PersonalInfoMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *PersonalInfoMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *PersonalInfoMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[personalinfo.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *PersonalInfoMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *PersonalInfoMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, personalinfo.FieldWebsite)
}

// SetLinkedin sets the "linkedin" field.
func (m *PersonalInfoMutation) SetLinkedin(s string) {
	m.linkedin = &s
}

// Linkedin returns the value of the "linkedin" field in the mutation.
func (m *PersonalInfoMutation) Linkedin() (r string, exists bool) {
	v := m.linkedin
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedin returns the old "linkedin" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldLinkedin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedin: %w", err)
	}
	return oldValue.Linkedin, nil
}

// ClearLinkedin clears the value of the "linkedin" field.
func (m *PersonalInfoMutation) ClearLinkedin() {
	m.linkedin = nil
	m.clearedFields[personalinfo.FieldLinkedin] = struct{}{}
}

// LinkedinCleared returns if the "linkedin" field was cleared in this mutation.
func (m *PersonalInfoMutation) LinkedinCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldLinkedin]
	return ok
}

// ResetLinkedin resets all changes to the "linkedin" field.
func (m *PersonalInfoMutation) ResetLinkedin() {
	m.linkedin = nil
	delete(m.clearedFields, personalinfo.FieldLinkedin)
}

// SetGithub sets the "github" field.
func (m *PersonalInfoMutation) SetGithub(s string) {
	m.github = &s
}

// Github returns the value of the "github" field in the mutation.
func (m *PersonalInfoMutation) Github() (r string, exists bool) {
	v := m.github
	if v == nil {
		return
	}
	return *v, true
}

// OldGithub returns the old "github" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldGithub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithub: %w", err)
	}
	return oldValue.Github, nil
}

// ClearGithub clears the value of the "github" field.
func (m *PersonalInfoMutation) ClearGithub() {
	m.github = nil
	m.clearedFields[personalinfo.FieldGithub] = struct{}{}
}

// GithubCleared returns if the "github" field was cleared in this mutation.
func (m *PersonalInfoMutation) GithubCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldGithub]
	return ok
}

// ResetGithub resets all changes to the "github" field.
func (m *PersonalInfoMutation) ResetGithub() {
	m.github = nil
	delete(m.clearedFields, personalinfo.FieldGithub)
}

// SetTwitter sets the "twitter" field.
func (m *PersonalInfoMutation) SetTwitter(s string) {
	m.twitter = &s
}

// Twitter returns the value of the "twitter" field in the mutation.
func (m *PersonalInfoMutation) Twitter() (r string, exists bool) {
	v := m.twitter
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitter returns the old "twitter" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldTwitter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitter: %w", err)
	}
	return oldValue.Twitter, nil
}

// ClearTwitter clears the value of the "twitter" field.
func (m *PersonalInfoMutation) ClearTwitter() {
	m.twitter = nil
	m.clearedFields[personalinfo.FieldTwitter] = struct{}{}
}

// TwitterCleared returns if the "twitter" field was cleared in this mutation.
func (m *PersonalInfoMutation) TwitterCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldTwitter]
	return ok
}

// ResetTwitter resets all changes to the "twitter" field.
func (m *PersonalInfoMutation) ResetTwitter() {
	m.twitter = nil
	delete(m.clearedFields, personalinfo.FieldTwitter)
}

// SetBio sets the "bio" field.
func (m *PersonalInfoMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *PersonalInfoMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *PersonalInfoMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[personalinfo.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *PersonalInfoMutation) BioCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *PersonalInfoMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, personalinfo.FieldBio)
}

// SetPhotoURL sets the "photo_url" field.
func (m *PersonalInfoMutation) SetPhotoURL(s string) {
	m.photo_url = &s
}

// PhotoURL returns the value of the "photo_url" field in the mutation.
func (m *PersonalInfoMutation) PhotoURL() (r string, exists bool) {
	v := m.photo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "photo_url" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldPhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ClearPhotoURL clears the value of the "photo_url" field.
func (m *PersonalInfoMutation) ClearPhotoURL() {
	m.photo_url = nil
	m.clearedFields[personalinfo.FieldPhotoURL] = struct{}{}
}

// PhotoURLCleared returns if the "photo_url" field was cleared in this mutation.
func (m *PersonalInfoMutation) PhotoURLCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldPhotoURL]
	return ok
}

// ResetPhotoURL resets all changes to the "photo_url" field.
func (m *PersonalInfoMutation) ResetPhotoURL() {
	m.photo_url = nil
	delete(m.clearedFields, personalinfo.FieldPhotoURL)
}

// SetResumeID sets the "resume" edge to the Resume entity by id.
func (m *PersonalInfoMutation) SetResumeID(id int) {
	m.resume = &id
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *PersonalInfoMutation) ClearResume() {
	m.clearedresume = true
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *PersonalInfoMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeID returns the "resume" edge ID in the mutation.
func (m *PersonalInfoMutation) ResumeID() (id int, exists bool) {
	if m.resume != nil {
		return *m.resume, true
	}
	return
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *PersonalInfoMutation) ResumeIDs() (ids []int) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *PersonalInfoMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the PersonalInfoMutation builder.
func (m *PersonalInfoMutation) Where(ps ...predicate.PersonalInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonalInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonalInfo).
func (m *PersonalInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalInfoMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.first_name != nil {
		fields = append(fields, personalinfo.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, personalinfo.FieldLastName)
	}
	if m.profession != nil {
		fields = append(fields, personalinfo.FieldProfession)
	}
	if m.email != nil {
		fields = append(fields, personalinfo.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, personalinfo.FieldPhone)
	}
	if m.address != nil {
		fields = append(fields, personalinfo.FieldAddress)
	}
	if m.website != nil {
		fields = append(fields, personalinfo.FieldWebsite)
	}
	if m.linkedin != nil {
		fields = append(fields, personalinfo.FieldLinkedin)
	}
	if m.github != nil {
		fields = append(fields, personalinfo.FieldGithub)
	}
	if m.twitter != nil {
		fields = append(fields, personalinfo.FieldTwitter)
	}
	if m.bio != nil {
		fields = append(fields, personalinfo.FieldBio)
	}
	if m.photo_url != nil {
		fields = append(fields, personalinfo.FieldPhotoURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personalinfo.FieldFirstName:
		return m.FirstName()
	case personalinfo.FieldLastName:
		return m.LastName()
	case personalinfo.FieldProfession:
		return m.Profession()
	case personalinfo.FieldEmail:
		return m.Email()
	case personalinfo.FieldPhone:
		return m.Phone()
	case personalinfo.FieldAddress:
		return m.Address()
	case personalinfo.FieldWebsite:
		return m.Website()
	case personalinfo.FieldLinkedin:
		return m.Linkedin()
	case personalinfo.FieldGithub:
		return m.Github()
	case personalinfo.FieldTwitter:
		return m.Twitter()
	case personalinfo.FieldBio:
		return m.Bio()
	case personalinfo.FieldPhotoURL:
		return m.PhotoURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personalinfo.FieldFirstName:
		return m.OldFirstName(ctx)
	case personalinfo.FieldLastName:
		return m.OldLastName(ctx)
	case personalinfo.FieldProfession:
		return m.OldProfession(ctx)
	case personalinfo.FieldEmail:
		return m.OldEmail(ctx)
	case personalinfo.FieldPhone:
		return m.OldPhone(ctx)
	case personalinfo.FieldAddress:
		return m.OldAddress(ctx)
	case personalinfo.FieldWebsite:
		return m.OldWebsite(ctx)
	case personalinfo.FieldLinkedin:
		return m.OldLinkedin(ctx)
	case personalinfo.FieldGithub:
		return m.OldGithub(ctx)
	case personalinfo.FieldTwitter:
		return m.OldTwitter(ctx)
	case personalinfo.FieldBio:
		return m.OldBio(ctx)
	case personalinfo.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	}
	return nil, fmt.Errorf("unknown PersonalInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personalinfo.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case personalinfo.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case personalinfo.FieldProfession:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfession(v)
		return nil
	case personalinfo.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case personalinfo.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case personalinfo.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case personalinfo.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case personalinfo.FieldLinkedin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedin(v)
		return nil
	case personalinfo.FieldGithub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithub(v)
		return nil
	case personalinfo.FieldTwitter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitter(v)
		return nil
	case personalinfo.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case personalinfo.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonalInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personalinfo.FieldPhone) {
		fields = append(fields, personalinfo.FieldPhone)
	}
	if m.FieldCleared(personalinfo.FieldAddress) {
		fields = append(fields, personalinfo.FieldAddress)
	}
	if m.FieldCleared(personalinfo.FieldWebsite) {
		fields = append(fields, personalinfo.FieldWebsite)
	}
	if m.FieldCleared(personalinfo.FieldLinkedin) {
		fields = append(fields, personalinfo.FieldLinkedin)
	}
	if m.FieldCleared(personalinfo.FieldGithub) {
		fields = append(fields, personalinfo.FieldGithub)
	}
	if m.FieldCleared(personalinfo.FieldTwitter) {
		fields = append(fields, personalinfo.FieldTwitter)
	}
	if m.FieldCleared(personalinfo.FieldBio) {
		fields = append(fields, personalinfo.FieldBio)
	}
	if m.FieldCleared(personalinfo.FieldPhotoURL) {
		fields = append(fields, personalinfo.FieldPhotoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalInfoMutation) ClearField(name string) error {
	switch name {
	case personalinfo.FieldPhone:
		m.ClearPhone()
		return nil
	case personalinfo.FieldAddress:
		m.ClearAddress()
		return nil
	case personalinfo.FieldWebsite:
		m.ClearWebsite()
		return nil
	case personalinfo.FieldLinkedin:
		m.ClearLinkedin()
		return nil
	case personalinfo.FieldGithub:
		m.ClearGithub()
		return nil
	case personalinfo.FieldTwitter:
		m.ClearTwitter()
		return nil
	case personalinfo.FieldBio:
		m.ClearBio()
		return nil
	case personalinfo.FieldPhotoURL:
		m.ClearPhotoURL()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalInfoMutation) ResetField(name string) error {
	switch name {
	case personalinfo.FieldFirstName:
		m.ResetFirstName()
		return nil
	case personalinfo.FieldLastName:
		m.ResetLastName()
		return nil
	case personalinfo.FieldProfession:
		m.ResetProfession()
		return nil
	case personalinfo.FieldEmail:
		m.ResetEmail()
		return nil
	case personalinfo.FieldPhone:
		m.ResetPhone()
		return nil
	case personalinfo.FieldAddress:
		m.ResetAddress()
		return nil
	case personalinfo.FieldWebsite:
		m.ResetWebsite()
		return nil
	case personalinfo.FieldLinkedin:
		m.ResetLinkedin()
		return nil
	case personalinfo.FieldGithub:
		m.ResetGithub()
		return nil
	case personalinfo.FieldTwitter:
		m.ResetTwitter()
		return nil
	case personalinfo.FieldBio:
		m.ResetBio()
		return nil
	case personalinfo.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, personalinfo.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personalinfo.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, personalinfo.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case personalinfo.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalInfoMutation) ClearEdge(name string) error {
	switch name {
	case personalinfo.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalInfoMutation) ResetEdge(name string) error {
	switch name {
	case personalinfo.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	url           *string
	skills        *string
	start_date    *time.Time
	end_date      *time.Time
	clearedFields map[string]struct{}
	resume        map[int]struct{}
	removedresume map[int]struct{}
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*Project, error)
	predicates    []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// SetURL sets the "url" field.
func (m *ProjectMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ProjectMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ProjectMutation) ClearURL() {
	m.url = nil
	m.clearedFields[project.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ProjectMutation) URLCleared() bool {
	_, ok := m.clearedFields[project.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ProjectMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, project.FieldURL)
}

// SetSkills sets the "skills" field.
func (m *ProjectMutation) SetSkills(s string) {
	m.skills = &s
}

// Skills returns the value of the "skills" field in the mutation.
func (m *ProjectMutation) Skills() (r string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSkills(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// ClearSkills clears the value of the "skills" field.
func (m *ProjectMutation) ClearSkills() {
	m.skills = nil
	m.clearedFields[project.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *ProjectMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[project.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *ProjectMutation) ResetSkills() {
	m.skills = nil
	delete(m.clearedFields, project.FieldSkills)
}

// SetStartDate sets the "start_date" field.
func (m *ProjectMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[project.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[project.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, project.FieldEndDate)
}

// AddResumeIDs adds the "resume" edge to the Resume entity by ids.
func (m *ProjectMutation) AddResumeIDs(ids ...int) {
	if m.resume == nil {
		m.resume = make(map[int]struct{})
	}
	for i := range ids {
		m.resume[ids[i]] = struct{}{}
	}
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ProjectMutation) ClearResume() {
	m.clearedresume = true
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ProjectMutation) ResumeCleared() bool {
	return m.clearedresume
}

// RemoveResumeIDs removes the "resume" edge to the Resume entity by IDs.
func (m *ProjectMutation) RemoveResumeIDs(ids ...int) {
	if m.removedresume == nil {
		m.removedresume = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resume, ids[i])
		m.removedresume[ids[i]] = struct{}{}
	}
}

// RemovedResume returns the removed IDs of the "resume" edge to the Resume entity.
func (m *ProjectMutation) RemovedResumeIDs() (ids []int) {
	for id := range m.removedresume {
		ids = append(ids, id)
	}
	return
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
func (m *ProjectMutation) ResumeIDs() (ids []int) {
	for id := range m.resume {
		ids = append(ids, id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ProjectMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
	m.removedresume = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, project.FieldURL)
	}
	if m.skills != nil {
		fields = append(fields, project.FieldSkills)
	}
	if m.start_date != nil {
		fields = append(fields, project.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, project.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldURL:
		return m.URL()
	case project.FieldSkills:
		return m.Skills()
	case project.FieldStartDate:
		return m.StartDate()
	case project.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldURL:
		return m.OldURL(ctx)
	case project.FieldSkills:
		return m.OldSkills(ctx)
	case project.FieldStartDate:
		return m.OldStartDate(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case project.FieldSkills:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case project.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldURL) {
		fields = append(fields, project.FieldURL)
	}
	if m.FieldCleared(project.FieldSkills) {
		fields = append(fields, project.FieldSkills)
	}
	if m.FieldCleared(project.FieldEndDate) {
		fields = append(fields, project.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldURL:
		m.ClearURL()
		return nil
	case project.FieldSkills:
		m.ClearSkills()
		return nil
	case project.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldURL:
		m.ResetURL()
		return nil
	case project.FieldSkills:
		m.ResetSkills()
		return nil
	case project.FieldStartDate:
		m.ResetStartDate()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, project.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeResume:
		ids := make([]ent.Value, 0, len(m.resume))
		for id := range m.resume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedresume != nil {
		edges = append(edges, project.EdgeResume)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeResume:
		ids := make([]ent.Value, 0, len(m.removedresume))
		for id := range m.removedresume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, project.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ResumeMutation represents an operation that mutates the Resume nodes in the graph.
type ResumeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	created_at            *time.Time
	updated_at            *time.Time
	shared                *bool
	share_code            *string
	status                *resume.Status
	clearedFields         map[string]struct{}
	owner                 *int
	clearedowner          bool
	template              *int
	clearedtemplate       bool
	personal_info         *int
	clearedpersonal_info  bool
	experiences           map[int]struct{}
	removedexperiences    map[int]struct{}
	clearedexperiences    bool
	educations            map[int]struct{}
	removededucations     map[int]struct{}
	clearededucations     bool
	skills                map[int]struct{}
	removedskills         map[int]struct{}
	clearedskills         bool
	projects              map[int]struct{}
	removedprojects       map[int]struct{}
	clearedprojects       bool
	certifications        map[int]struct{}
	removedcertifications map[int]struct{}
	clearedcertifications bool
	done                  bool
	oldValue              func(context.Context) (*Resume, error)
	predicates            []predicate.Resume
}

var _ ent.Mutation = (*ResumeMutation)(nil)

// resumeOption allows management of the mutation configuration using functional options.
type resumeOption func(*ResumeMutation)

// newResumeMutation creates new mutation for the Resume entity.
func newResumeMutation(c config, op Op, opts ...resumeOption) *ResumeMutation {
	m := &ResumeMutation{
		config:        c,
		op:            op,
		typ:           TypeResume,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeID sets the ID field of the mutation.
func withResumeID(id int) resumeOption {
	return func(m *ResumeMutation) {
		var (
			err   error
			once  sync.Once
			value *Resume
		)
		m.oldValue = func(ctx context.Context) (*Resume, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resume.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResume sets the old Resume of the mutation.
func withResume(node *Resume) resumeOption {
	return func(m *ResumeMutation) {
		m.oldValue = func(context.Context) (*Resume, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resume.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ResumeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResumeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResumeMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetShared sets the "shared" field.
func (m *ResumeMutation) SetShared(b bool) {
	m.shared = &b
}

// Shared returns the value of the "shared" field in the mutation.
func (m *ResumeMutation) Shared() (r bool, exists bool) {
	v := m.shared
	if v == nil {
		return
	}
	return *v, true
}

// OldShared returns the old "shared" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldShared(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShared is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShared requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShared: %w", err)
	}
	return oldValue.Shared, nil
}

// ResetShared resets all changes to the "shared" field.
func (m *ResumeMutation) ResetShared() {
	m.shared = nil
}

// SetShareCode sets the "share_code" field.
func (m *ResumeMutation) SetShareCode(s string) {
	m.share_code = &s
}

// ShareCode returns the value of the "share_code" field in the mutation.
func (m *ResumeMutation) ShareCode() (r string, exists bool) {
	v := m.share_code
	if v == nil {
		return
	}
	return *v, true
}

// OldShareCode returns the old "share_code" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldShareCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareCode: %w", err)
	}
	return oldValue.ShareCode, nil
}

// ClearShareCode clears the value of the "share_code" field.
func (m *ResumeMutation) ClearShareCode() {
	m.share_code = nil
	m.clearedFields[resume.FieldShareCode] = struct{}{}
}

// ShareCodeCleared returns if the "share_code" field was cleared in this mutation.
func (m *ResumeMutation) ShareCodeCleared() bool {
	_, ok := m.clearedFields[resume.FieldShareCode]
	return ok
}

// ResetShareCode resets all changes to the "share_code" field.
func (m *ResumeMutation) ResetShareCode() {
	m.share_code = nil
	delete(m.clearedFields, resume.FieldShareCode)
}

// SetStatus sets the "status" field.
func (m *ResumeMutation) SetStatus(r resume.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ResumeMutation) Status() (r resume.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldStatus(ctx context.Context) (v resume.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ResumeMutation) ResetStatus() {
	m.status = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ResumeMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ResumeMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ResumeMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ResumeMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ResumeMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ResumeMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetTemplateID sets the "template" edge to the Template entity by id.
func (m *ResumeMutation) SetTemplateID(id int) {
	m.template = &id
}

// ClearTemplate clears the "template" edge to the Template entity.
func (m *ResumeMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared reports if the "template" edge to the Template entity was cleared.
func (m *ResumeMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateID returns the "template" edge ID in the mutation.
func (m *ResumeMutation) TemplateID() (id int, exists bool) {
	if m.template != nil {
		return *m.template, true
	}
	return
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *ResumeMutation) TemplateIDs() (ids []int) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *ResumeMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// SetPersonalInfoID sets the "personal_info" edge to the PersonalInfo entity by id.
func (m *ResumeMutation) SetPersonalInfoID(id int) {
	m.personal_info = &id
}

// ClearPersonalInfo clears the "personal_info" edge to the PersonalInfo entity.
func (m *ResumeMutation) ClearPersonalInfo() {
	m.clearedpersonal_info = true
}

// PersonalInfoCleared reports if the "personal_info" edge to the PersonalInfo entity was cleared.
func (m *ResumeMutation) PersonalInfoCleared() bool {
	return m.clearedpersonal_info
}

// PersonalInfoID returns the "personal_info" edge ID in the mutation.
func (m *ResumeMutation) PersonalInfoID() (id int, exists bool) {
	if m.personal_info != nil {
		return *m.personal_info, true
	}
	return
}

// PersonalInfoIDs returns the "personal_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonalInfoID instead. It exists only for internal usage by the builders.
func (m *ResumeMutation) PersonalInfoIDs() (ids []int) {
	if id := m.personal_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersonalInfo resets all changes to the "personal_info" edge.
func (m *ResumeMutation) ResetPersonalInfo() {
	m.personal_info = nil
	m.clearedpersonal_info = false
}

// AddExperienceIDs adds the "experiences" edge to the Experience entity by ids.
func (m *ResumeMutation) AddExperienceIDs(ids ...int) {
	if m.experiences == nil {
		m.experiences = make(map[int]struct{})
	}
	for i := range ids {
		m.experiences[ids[i]] = struct{}{}
	}
}

// ClearExperiences clears the "experiences" edge to the Experience entity.
func (m *ResumeMutation) ClearExperiences() {
	m.clearedexperiences = true
}

// ExperiencesCleared reports if the "experiences" edge to the Experience entity was cleared.
func (m *ResumeMutation) ExperiencesCleared() bool {
	return m.clearedexperiences
}

// RemoveExperienceIDs removes the "experiences" edge to the Experience entity by IDs.
func (m *ResumeMutation) RemoveExperienceIDs(ids ...int) {
	if m.removedexperiences == nil {
		m.removedexperiences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.experiences, ids[i])
		m.removedexperiences[ids[i]] = struct{}{}
	}
}

// RemovedExperiences returns the removed IDs of the "experiences" edge to the Experience entity.
func (m *ResumeMutation) RemovedExperiencesIDs() (ids []int) {
	for id := range m.removedexperiences {
		ids = append(ids, id)
	}
	return
}

// ExperiencesIDs returns the "experiences" edge IDs in the mutation.
func (m *ResumeMutation) ExperiencesIDs() (ids []int) {
	for id := range m.experiences {
		ids = append(ids, id)
	}
	return
}

// ResetExperiences resets all changes to the "experiences" edge.
func (m *ResumeMutation) ResetExperiences() {
	m.experiences = nil
	m.clearedexperiences = false
	m.removedexperiences = nil
}

// AddEducationIDs adds the "educations" edge to the Education entity by ids.
func (m *ResumeMutation) AddEducationIDs(ids ...int) {
	if m.educations == nil {
		m.educations = make(map[int]struct{})
	}
	for i := range ids {
		m.educations[ids[i]] = struct{}{}
	}
}

// ClearEducations clears the "educations" edge to the Education entity.
func (m *ResumeMutation) ClearEducations() {
	m.clearededucations = true
}

// EducationsCleared reports if the "educations" edge to the Education entity was cleared.
func (m *ResumeMutation) EducationsCleared() bool {
	return m.clearededucations
}

// RemoveEducationIDs removes the "educations" edge to the Education entity by IDs.
func (m *ResumeMutation) RemoveEducationIDs(ids ...int) {
	if m.removededucations == nil {
		m.removededucations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.educations, ids[i])
		m.removededucations[ids[i]] = struct{}{}
	}
}

// RemovedEducations returns the removed IDs of the "educations" edge to the Education entity.
func (m *ResumeMutation) RemovedEducationsIDs() (ids []int) {
	for id := range m.removededucations {
		ids = append(ids, id)
	}
	return
}

// EducationsIDs returns the "educations" edge IDs in the mutation.
func (m *ResumeMutation) EducationsIDs() (ids []int) {
	for id := range m.educations {
		ids = append(ids, id)
	}
	return
}

// ResetEducations resets all changes to the "educations" edge.
func (m *ResumeMutation) ResetEducations() {
	m.educations = nil
	m.clearededucations = false
	m.removededucations = nil
}

// AddSkillIDs adds the "skills" edge to the Skill entity by ids.
func (m *ResumeMutation) AddSkillIDs(ids ...int) {
	if m.skills == nil {
		m.skills = make(map[int]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the Skill entity.
func (m *ResumeMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the Skill entity was cleared.
func (m *ResumeMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the Skill entity by IDs.
func (m *ResumeMutation) RemoveSkillIDs(ids ...int) {
	if m.removedskills == nil {
		m.removedskills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the Skill entity.
func (m *ResumeMutation) RemovedSkillsIDs() (ids []int) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *ResumeMutation) SkillsIDs() (ids []int) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *ResumeMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *ResumeMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *ResumeMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *ResumeMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *ResumeMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *ResumeMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ResumeMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ResumeMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddCertificationIDs adds the "certifications" edge to the Certification entity by ids.
func (m *ResumeMutation) AddCertificationIDs(ids ...int) {
	if m.certifications == nil {
		m.certifications = make(map[int]struct{})
	}
	for i := range ids {
		m.certifications[ids[i]] = struct{}{}
	}
}

// ClearCertifications clears the "certifications" edge to the Certification entity.
func (m *ResumeMutation) ClearCertifications() {
	m.clearedcertifications = true
}

// CertificationsCleared reports if the "certifications" edge to the Certification entity was cleared.
func (m *ResumeMutation) CertificationsCleared() bool {
	return m.clearedcertifications
}

// RemoveCertificationIDs removes the "certifications" edge to the Certification entity by IDs.
func (m *ResumeMutation) RemoveCertificationIDs(ids ...int) {
	if m.removedcertifications == nil {
		m.removedcertifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.certifications, ids[i])
		m.removedcertifications[ids[i]] = struct{}{}
	}
}

// RemovedCertifications returns the removed IDs of the "certifications" edge to the Certification entity.
func (m *ResumeMutation) RemovedCertificationsIDs() (ids []int) {
	for id := range m.removedcertifications {
		ids = append(ids, id)
	}
	return
}

// CertificationsIDs returns the "certifications" edge IDs in the mutation.
func (m *ResumeMutation) CertificationsIDs() (ids []int) {
	for id := range m.certifications {
		ids = append(ids, id)
	}
	return
}

// ResetCertifications resets all changes to the "certifications" edge.
func (m *ResumeMutation) ResetCertifications() {
	m.certifications = nil
	m.clearedcertifications = false
	m.removedcertifications = nil
}

// Where appends a list predicates to the ResumeMutation builder.
func (m *ResumeMutation) Where(ps ...predicate.Resume) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resume, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resume).
func (m *ResumeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, resume.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, resume.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resume.FieldUpdatedAt)
	}
	if m.shared != nil {
		fields = append(fields, resume.FieldShared)
	}
	if m.share_code != nil {
		fields = append(fields, resume.FieldShareCode)
	}
	if m.status != nil {
		fields = append(fields, resume.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resume.FieldName:
		return m.Name()
	case resume.FieldCreatedAt:
		return m.CreatedAt()
	case resume.FieldUpdatedAt:
		return m.UpdatedAt()
	case resume.FieldShared:
		return m.Shared()
	case resume.FieldShareCode:
		return m.ShareCode()
	case resume.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resume.FieldName:
		return m.OldName(ctx)
	case resume.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resume.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resume.FieldShared:
		return m.OldShared(ctx)
	case resume.FieldShareCode:
		return m.OldShareCode(ctx)
	case resume.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Resume field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resume.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resume.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resume.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resume.FieldShared:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShared(v)
		return nil
	case resume.FieldShareCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareCode(v)
		return nil
	case resume.FieldStatus:
		v, ok := value.(resume.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Resume field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resume numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resume.FieldShareCode) {
		fields = append(fields, resume.FieldShareCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeMutation) ClearField(name string) error {
	switch name {
	case resume.FieldShareCode:
		m.ClearShareCode()
		return nil
	}
	return fmt.Errorf("unknown Resume nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeMutation) ResetField(name string) error {
	switch name {
	case resume.FieldName:
		m.ResetName()
		return nil
	case resume.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resume.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resume.FieldShared:
		m.ResetShared()
		return nil
	case resume.FieldShareCode:
		m.ResetShareCode()
		return nil
	case resume.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Resume field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.owner != nil {
		edges = append(edges, resume.EdgeOwner)
	}
	if m.template != nil {
		edges = append(edges, resume.EdgeTemplate)
	}
	if m.personal_info != nil {
		edges = append(edges, resume.EdgePersonalInfo)
	}
	if m.experiences != nil {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.educations != nil {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.skills != nil {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.projects != nil {
		edges = append(edges, resume.EdgeProjects)
	}
	if m.certifications != nil {
		edges = append(edges, resume.EdgeCertifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resume.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case resume.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case resume.EdgePersonalInfo:
		if id := m.personal_info; id != nil {
			return []ent.Value{*id}
		}
	case resume.EdgeExperiences:
		ids := make([]ent.Value, 0, len(m.experiences))
		for id := range m.experiences {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.educations))
		for id := range m.educations {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeCertifications:
		ids := make([]ent.Value, 0, len(m.certifications))
		for id := range m.certifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedexperiences != nil {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.removededucations != nil {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.removedskills != nil {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.removedprojects != nil {
		edges = append(edges, resume.EdgeProjects)
	}
	if m.removedcertifications != nil {
		edges = append(edges, resume.EdgeCertifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resume.EdgeExperiences:
		ids := make([]ent.Value, 0, len(m.removedexperiences))
		for id := range m.removedexperiences {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.removededucations))
		for id := range m.removededucations {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeCertifications:
		ids := make([]ent.Value, 0, len(m.removedcertifications))
		for id := range m.removedcertifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedowner {
		edges = append(edges, resume.EdgeOwner)
	}
	if m.clearedtemplate {
		edges = append(edges, resume.EdgeTemplate)
	}
	if m.clearedpersonal_info {
		edges = append(edges, resume.EdgePersonalInfo)
	}
	if m.clearedexperiences {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.clearededucations {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.clearedskills {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.clearedprojects {
		edges = append(edges, resume.EdgeProjects)
	}
	if m.clearedcertifications {
		edges = append(edges, resume.EdgeCertifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeMutation) EdgeCleared(name string) bool {
	switch name {
	case resume.EdgeOwner:
		return m.clearedowner
	case resume.EdgeTemplate:
		return m.clearedtemplate
	case resume.EdgePersonalInfo:
		return m.clearedpersonal_info
	case resume.EdgeExperiences:
		return m.clearedexperiences
	case resume.EdgeEducations:
		return m.clearededucations
	case resume.EdgeSkills:
		return m.clearedskills
	case resume.EdgeProjects:
		return m.clearedprojects
	case resume.EdgeCertifications:
		return m.clearedcertifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeMutation) ClearEdge(name string) error {
	switch name {
	case resume.EdgeOwner:
		m.ClearOwner()
		return nil
	case resume.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case resume.EdgePersonalInfo:
		m.ClearPersonalInfo()
		return nil
	}
	return fmt.Errorf("unknown Resume unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeMutation) ResetEdge(name string) error {
	switch name {
	case resume.EdgeOwner:
		m.ResetOwner()
		return nil
	case resume.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case resume.EdgePersonalInfo:
		m.ResetPersonalInfo()
		return nil
	case resume.EdgeExperiences:
		m.ResetExperiences()
		return nil
	case resume.EdgeEducations:
		m.ResetEducations()
		return nil
	case resume.EdgeSkills:
		m.ResetSkills()
		return nil
	case resume.EdgeProjects:
		m.ResetProjects()
		return nil
	case resume.EdgeCertifications:
		m.ResetCertifications()
		return nil
	}
	return fmt.Errorf("unknown Resume edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	token         *string
	data          *[]byte
	expiry        *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetData sets the "data" field.
func (m *SessionMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *SessionMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *SessionMutation) ResetData() {
	m.data = nil
}

// SetExpiry sets the "expiry" field.
func (m *SessionMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *SessionMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *SessionMutation) ResetExpiry() {
	m.expiry = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.data != nil {
		fields = append(fields, session.FieldData)
	}
	if m.expiry != nil {
		fields = append(fields, session.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldToken:
		return m.Token()
	case session.FieldData:
		return m.Data()
	case session.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldToken:
		return m.OldToken(ctx)
	case session.FieldData:
		return m.OldData(ctx)
	case session.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case session.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldData:
		m.ResetData()
		return nil
	case session.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Session edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	category      *string
	level         *skill.Level
	clearedFields map[string]struct{}
	resume        map[int]struct{}
	removedresume map[int]struct{}
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*Skill, error)
	predicates    []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id int) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Skill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *SkillMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *SkillMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *SkillMutation) ResetCategory() {
	m.category = nil
}

// SetLevel sets the "level" field.
func (m *SkillMutation) SetLevel(s skill.Level) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *SkillMutation) Level() (r skill.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldLevel(ctx context.Context) (v skill.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *SkillMutation) ResetLevel() {
	m.level = nil
}

// AddResumeIDs adds the "resume" edge to the Resume entity by ids.
func (m *SkillMutation) AddResumeIDs(ids ...int) {
	if m.resume == nil {
		m.resume = make(map[int]struct{})
	}
	for i := range ids {
		m.resume[ids[i]] = struct{}{}
	}
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *SkillMutation) ClearResume() {
	m.clearedresume = true
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *SkillMutation) ResumeCleared() bool {
	return m.clearedresume
}

// RemoveResumeIDs removes the "resume" edge to the Resume entity by IDs.
func (m *SkillMutation) RemoveResumeIDs(ids ...int) {
	if m.removedresume == nil {
		m.removedresume = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resume, ids[i])
		m.removedresume[ids[i]] = struct{}{}
	}
}

// RemovedResume returns the removed IDs of the "resume" edge to the Resume entity.
func (m *SkillMutation) RemovedResumeIDs() (ids []int) {
	for id := range m.removedresume {
		ids = append(ids, id)
	}
	return
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
func (m *SkillMutation) ResumeIDs() (ids []int) {
	for id := range m.resume {
		ids = append(ids, id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *SkillMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
	m.removedresume = nil
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Skill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m.category != nil {
		fields = append(fields, skill.FieldCategory)
	}
	if m.level != nil {
		fields = append(fields, skill.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldName:
		return m.Name()
	case skill.FieldCategory:
		return m.Category()
	case skill.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldCategory:
		return m.OldCategory(ctx)
	case skill.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case skill.FieldLevel:
		v, ok := value.(skill.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldCategory:
		m.ResetCategory()
		return nil
	case skill.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, skill.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeResume:
		ids := make([]ent.Value, 0, len(m.resume))
		for id := range m.resume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedresume != nil {
		edges = append(edges, skill.EdgeResume)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeResume:
		ids := make([]ent.Value, 0, len(m.removedresume))
		for id := range m.removedresume {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, skill.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	switch name {
	case skill.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	switch name {
	case skill.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown Skill edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	description    *string
	sections       *[]string
	appendsections []string
	_config        **models.TemplateConfig
	thumbnail_url  *string
	preview_url    *string
	style          *string
	premium        *bool
	created_at     *time.Time
	clearedFields  map[string]struct{}
	owner          *int
	clearedowner   bool
	resumes        map[int]struct{}
	removedresumes map[int]struct{}
	clearedresumes bool
	done           bool
	oldValue       func(context.Context) (*Template, error)
	predicates     []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id int) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[template.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[template.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, template.FieldDescription)
}

// SetSections sets the "sections" field.
func (m *TemplateMutation) SetSections(s []string) {
	m.sections = &s
	m.appendsections = nil
}

// Sections returns the value of the "sections" field in the mutation.
func (m *TemplateMutation) Sections() (r []string, exists bool) {
	v := m.sections
	if v == nil {
		return
	}
	return *v, true
}

// OldSections returns the old "sections" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldSections(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSections is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSections requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSections: %w", err)
	}
	return oldValue.Sections, nil
}

// AppendSections adds s to the "sections" field.
func (m *TemplateMutation) AppendSections(s []string) {
	m.appendsections = append(m.appendsections, s...)
}

// AppendedSections returns the list of values that were appended to the "sections" field in this mutation.
func (m *TemplateMutation) AppendedSections() ([]string, bool) {
	if len(m.appendsections) == 0 {
		return nil, false
	}
	return m.appendsections, true
}

// ResetSections resets all changes to the "sections" field.
func (m *TemplateMutation) ResetSections() {
	m.sections = nil
	m.appendsections = nil
}

// SetConfig sets the "config" field.
func (m *TemplateMutation) SetConfig(mc *models.TemplateConfig) {
	m._config = &mc
}

// Config returns the value of the "config" field in the mutation.
func (m *TemplateMutation) Config() (r *models.TemplateConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldConfig(ctx context.Context) (v *models.TemplateConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *TemplateMutation) ResetConfig() {
	m._config = nil
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *TemplateMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *TemplateMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *TemplateMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[template.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *TemplateMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[template.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *TemplateMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, template.FieldThumbnailURL)
}

// SetPreviewURL sets the "preview_url" field.
func (m *TemplateMutation) SetPreviewURL(s string) {
	m.preview_url = &s
}

// PreviewURL returns the value of the "preview_url" field in the mutation.
func (m *TemplateMutation) PreviewURL() (r string, exists bool) {
	v := m.preview_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviewURL returns the old "preview_url" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldPreviewURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviewURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviewURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviewURL: %w", err)
	}
	return oldValue.PreviewURL, nil
}

// ClearPreviewURL clears the value of the "preview_url" field.
func (m *TemplateMutation) ClearPreviewURL() {
	m.preview_url = nil
	m.clearedFields[template.FieldPreviewURL] = struct{}{}
}

// PreviewURLCleared returns if the "preview_url" field was cleared in this mutation.
func (m *TemplateMutation) PreviewURLCleared() bool {
	_, ok := m.clearedFields[template.FieldPreviewURL]
	return ok
}

// ResetPreviewURL resets all changes to the "preview_url" field.
func (m *TemplateMutation) ResetPreviewURL() {
	m.preview_url = nil
	delete(m.clearedFields, template.FieldPreviewURL)
}

// SetStyle sets the "style" field.
func (m *TemplateMutation) SetStyle(s string) {
	m.style = &s
}

// Style returns the value of the "style" field in the mutation.
func (m *TemplateMutation) Style() (r string, exists bool) {
	v := m.style
	if v == nil {
		return
	}
	return *v, true
}

// OldStyle returns the old "style" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldStyle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStyle: %w", err)
	}
	return oldValue.Style, nil
}

// ResetStyle resets all changes to the "style" field.
func (m *TemplateMutation) ResetStyle() {
	m.style = nil
}

// SetPremium sets the "premium" field.
func (m *TemplateMutation) SetPremium(b bool) {
	m.premium = &b
}

// Premium returns the value of the "premium" field in the mutation.
func (m *TemplateMutation) Premium() (r bool, exists bool) {
	v := m.premium
	if v == nil {
		return
	}
	return *v, true
}

// OldPremium returns the old "premium" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPremium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPremium: %w", err)
	}
	return oldValue.Premium, nil
}

// ResetPremium resets all changes to the "premium" field.
func (m *TemplateMutation) ResetPremium() {
	m.premium = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TemplateMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TemplateMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TemplateMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TemplateMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TemplateMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddResumeIDs adds the "resumes" edge to the Resume entity by ids.
func (m *TemplateMutation) AddResumeIDs(ids ...int) {
	if m.resumes == nil {
		m.resumes = make(map[int]struct{})
	}
	for i := range ids {
		m.resumes[ids[i]] = struct{}{}
	}
}

// ClearResumes clears the "resumes" edge to the Resume entity.
func (m *TemplateMutation) ClearResumes() {
	m.clearedresumes = true
}

// ResumesCleared reports if the "resumes" edge to the Resume entity was cleared.
func (m *TemplateMutation) ResumesCleared() bool {
	return m.clearedresumes
}

// RemoveResumeIDs removes the "resumes" edge to the Resume entity by IDs.
func (m *TemplateMutation) RemoveResumeIDs(ids ...int) {
	if m.removedresumes == nil {
		m.removedresumes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resumes, ids[i])
		m.removedresumes[ids[i]] = struct{}{}
	}
}

// RemovedResumes returns the removed IDs of the "resumes" edge to the Resume entity.
func (m *TemplateMutation) RemovedResumesIDs() (ids []int) {
	for id := range m.removedresumes {
		ids = append(ids, id)
	}
	return
}

// ResumesIDs returns the "resumes" edge IDs in the mutation.
func (m *TemplateMutation) ResumesIDs() (ids []int) {
	for id := range m.resumes {
		ids = append(ids, id)
	}
	return
}

// ResetResumes resets all changes to the "resumes" edge.
func (m *TemplateMutation) ResetResumes() {
	m.resumes = nil
	m.clearedresumes = false
	m.removedresumes = nil
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.description != nil {
		fields = append(fields, template.FieldDescription)
	}
	if m.sections != nil {
		fields = append(fields, template.FieldSections)
	}
	if m._config != nil {
		fields = append(fields, template.FieldConfig)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, template.FieldThumbnailURL)
	}
	if m.preview_url != nil {
		fields = append(fields, template.FieldPreviewURL)
	}
	if m.style != nil {
		fields = append(fields, template.FieldStyle)
	}
	if m.premium != nil {
		fields = append(fields, template.FieldPremium)
	}
	if m.created_at != nil {
		fields = append(fields, template.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldName:
		return m.Name()
	case template.FieldDescription:
		return m.Description()
	case template.FieldSections:
		return m.Sections()
	case template.FieldConfig:
		return m.Config()
	case template.FieldThumbnailURL:
		return m.ThumbnailURL()
	case template.FieldPreviewURL:
		return m.PreviewURL()
	case template.FieldStyle:
		return m.Style()
	case template.FieldPremium:
		return m.Premium()
	case template.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldDescription:
		return m.OldDescription(ctx)
	case template.FieldSections:
		return m.OldSections(ctx)
	case template.FieldConfig:
		return m.OldConfig(ctx)
	case template.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case template.FieldPreviewURL:
		return m.OldPreviewURL(ctx)
	case template.FieldStyle:
		return m.OldStyle(ctx)
	case template.FieldPremium:
		return m.OldPremium(ctx)
	case template.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case template.FieldSections:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSections(v)
		return nil
	case template.FieldConfig:
		v, ok := value.(*models.TemplateConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case template.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case template.FieldPreviewURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviewURL(v)
		return nil
	case template.FieldStyle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStyle(v)
		return nil
	case template.FieldPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPremium(v)
		return nil
	case template.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldDescription) {
		fields = append(fields, template.FieldDescription)
	}
	if m.FieldCleared(template.FieldThumbnailURL) {
		fields = append(fields, template.FieldThumbnailURL)
	}
	if m.FieldCleared(template.FieldPreviewURL) {
		fields = append(fields, template.FieldPreviewURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldDescription:
		m.ClearDescription()
		return nil
	case template.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case template.FieldPreviewURL:
		m.ClearPreviewURL()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldDescription:
		m.ResetDescription()
		return nil
	case template.FieldSections:
		m.ResetSections()
		return nil
	case template.FieldConfig:
		m.ResetConfig()
		return nil
	case template.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case template.FieldPreviewURL:
		m.ResetPreviewURL()
		return nil
	case template.FieldStyle:
		m.ResetStyle()
		return nil
	case template.FieldPremium:
		m.ResetPremium()
		return nil
	case template.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, template.EdgeOwner)
	}
	if m.resumes != nil {
		edges = append(edges, template.EdgeResumes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case template.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.resumes))
		for id := range m.resumes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedresumes != nil {
		edges = append(edges, template.EdgeResumes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.removedresumes))
		for id := range m.removedresumes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, template.EdgeOwner)
	}
	if m.clearedresumes {
		edges = append(edges, template.EdgeResumes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case template.EdgeOwner:
		return m.clearedowner
	case template.EdgeResumes:
		return m.clearedresumes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	switch name {
	case template.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	switch name {
	case template.EdgeOwner:
		m.ResetOwner()
		return nil
	case template.EdgeResumes:
		m.ResetResumes()
		return nil
	}
	return fmt.Errorf("unknown Template edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	email            *string
	password_hash    *string
	created_at       *time.Time
	updated_at       *time.Time
	role             *user.Role
	verified         *bool
	clearedFields    map[string]struct{}
	resumes          map[int]struct{}
	removedresumes   map[int]struct{}
	clearedresumes   bool
	templates        map[int]struct{}
	removedtemplates map[int]struct{}
	clearedtemplates bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetVerified sets the "verified" field.
func (m *UserMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *UserMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *UserMutation) ResetVerified() {
	m.verified = nil
}

// AddResumeIDs adds the "resumes" edge to the Resume entity by ids.
func (m *UserMutation) AddResumeIDs(ids ...int) {
	if m.resumes == nil {
		m.resumes = make(map[int]struct{})
	}
	for i := range ids {
		m.resumes[ids[i]] = struct{}{}
	}
}

// ClearResumes clears the "resumes" edge to the Resume entity.
func (m *UserMutation) ClearResumes() {
	m.clearedresumes = true
}

// ResumesCleared reports if the "resumes" edge to the Resume entity was cleared.
func (m *UserMutation) ResumesCleared() bool {
	return m.clearedresumes
}

// RemoveResumeIDs removes the "resumes" edge to the Resume entity by IDs.
func (m *UserMutation) RemoveResumeIDs(ids ...int) {
	if m.removedresumes == nil {
		m.removedresumes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resumes, ids[i])
		m.removedresumes[ids[i]] = struct{}{}
	}
}

// RemovedResumes returns the removed IDs of the "resumes" edge to the Resume entity.
func (m *UserMutation) RemovedResumesIDs() (ids []int) {
	for id := range m.removedresumes {
		ids = append(ids, id)
	}
	return
}

// ResumesIDs returns the "resumes" edge IDs in the mutation.
func (m *UserMutation) ResumesIDs() (ids []int) {
	for id := range m.resumes {
		ids = append(ids, id)
	}
	return
}

// ResetResumes resets all changes to the "resumes" edge.
func (m *UserMutation) ResetResumes() {
	m.resumes = nil
	m.clearedresumes = false
	m.removedresumes = nil
}

// AddTemplateIDs adds the "templates" edge to the Template entity by ids.
func (m *UserMutation) AddTemplateIDs(ids ...int) {
	if m.templates == nil {
		m.templates = make(map[int]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the "templates" edge to the Template entity.
func (m *UserMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared reports if the "templates" edge to the Template entity was cleared.
func (m *UserMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the "templates" edge to the Template entity by IDs.
func (m *UserMutation) RemoveTemplateIDs(ids ...int) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.templates, ids[i])
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed IDs of the "templates" edge to the Template entity.
func (m *UserMutation) RemovedTemplatesIDs() (ids []int) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the "templates" edge IDs in the mutation.
func (m *UserMutation) TemplatesIDs() (ids []int) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates resets all changes to the "templates" edge.
func (m *UserMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.verified != nil {
		fields = append(fields, user.FieldVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldRole:
		return m.Role()
	case user.FieldVerified:
		return m.Verified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldVerified:
		return m.OldVerified(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldVerified:
		m.ResetVerified()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.resumes != nil {
		edges = append(edges, user.EdgeResumes)
	}
	if m.templates != nil {
		edges = append(edges, user.EdgeTemplates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.resumes))
		for id := range m.resumes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedresumes != nil {
		edges = append(edges, user.EdgeResumes)
	}
	if m.removedtemplates != nil {
		edges = append(edges, user.EdgeTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.removedresumes))
		for id := range m.removedresumes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresumes {
		edges = append(edges, user.EdgeResumes)
	}
	if m.clearedtemplates {
		edges = append(edges, user.EdgeTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeResumes:
		return m.clearedresumes
	case user.EdgeTemplates:
		return m.clearedtemplates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeResumes:
		m.ResetResumes()
		return nil
	case user.EdgeTemplates:
		m.ResetTemplates()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
